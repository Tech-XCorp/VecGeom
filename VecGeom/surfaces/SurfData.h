#ifndef VECGEOM_SURFACE_SURFDATA_H_
#define VECGEOM_SURFACE_SURFDATA_H_

#include <VecGeom/base/Transformation3D.h>

namespace vgbrep {

template <typename Real_t>
struct RangeMask {
  Real_t range[2];
};

template <typename Real_t, typename Real_s = Real_t>
struct CylData {
  Real_t           radius{0};     ///< Cylinder radius

  CylData(Real_s rad) : radius(rad) {}
};


template <typename Real_t, typename Real_s = Real_t>
using SphData = CylData<Real_t, Real_s>;

template <typename Real_t, typename Real_s = Real_t>
struct ConeData {
  Real_t           radius{0};       ///< Cone radus at Z = 0
  Real_t           slope{0};     ///< Cone slope  --> for cyl extension this would be 0

  ConeData(Real_s rad, Real_s slope) : radius(rad), slope(slope) {}
};

// We need replicable surfaces, for memory reasons. All surfaces generated by a solid are positioned
// using identical local transformations, while the solid itself will use a different global transformation
// depending on the placement. So it makes sense to use tuples of global + local transformation. LocalSurface
// will use the local component, while portals will use the full tuple.
struct CombiTrans {
  int fLocalT{-1};      ///< index of the local surface transformation
  int fTouchableT{-1};  ///< index of touchable (containing the surface) transformation
};

/*
 * The main surface storage utility, providing access by index to:
 *    * global and local transformations applied to surfaces
 *    * surface data per surface type
 *    * mask data per mask type
 *    * imprint data (list of masks)
 */
template <typename Real_t>
struct SurfData {

  using Transformation = vecgeom::Transformation3D;
  using CylData_t = CylData<Real_t>;
  using ConeData_t = ConeData<Real_t>;
  using SphData_t = SphData<Real_t>;
  using RangeMask_t = RangeMask<Real_t>;

  /// Transformations. A portal transformation is a tuple global + local
  Transformation         *fLocalTrans {nullptr};       ///< Local surface transformations in frame of parent solid
  Transformation         *fTouchableTrans {nullptr};   ///< Touchable global transformations

  /// Cylindrical surface data (radius)
  CylData_t              *fCylSphData {nullptr};       ///< Cyl and sphere data
  ConeData_t             *fConeData {nullptr};         ///< Cone data

  /// Mask data
  RangeMask_t            *fRangeData {nullptr};
  
  
  /// Transformation getters
  Transformation const &LocalT(int id) const { return fLocalTrans[id]; }
  Transformation const &TouchableT(int id) const { return fTouchableTrans[id]; }
  void                  GlobalT(CombiTrans const &ct, Transformation &global)
  {
    global = TouchableT(ct.fTouchableT);
    global.MultiplyFromRight(LocalT(ct.fLocalT));
  }

  /// Surface data accessors
  CylData_t const        &GetCylData(int id) const { return fCylSphData[id]; }
  SphData_t const        &GetSphData(int id) const { return fCylSphData[id]; }
  ConeData_t const       &GetConeData(int id) const { return fConeData[id]; }
  RangeMask_t const      &GetRangeMask(int id) const { return fRangeData[id]; }

};

} // namespace vgbrep

#endif